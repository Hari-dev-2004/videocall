{% extends "base.html" %}

{% block title %}{{ room_name }} - VideoCall{% endblock %}

{% block extra_css %}
<style>
    .video-container {
        display: grid;
        gap: 15px;
        margin-bottom: 20px;
        min-height: 400px;
    }

    .video-container.single {
        grid-template-columns: 1fr;
    }

    .video-container.dual {
        grid-template-columns: 1fr 1fr;
    }

    .video-container.triple {
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 1fr 1fr;
    }
    
    .video-container.quad {
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 1fr 1fr;
    }

    .video-container.multiple {
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        grid-auto-rows: 1fr;
    }

    .video-wrapper {
        position: relative;
        border-radius: 12px;
        overflow: hidden;
        background: #000;
        aspect-ratio: 16/9;
    }

    .video-element {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 12px;
    }

    .video-overlay {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(transparent, rgba(0,0,0,0.7));
        color: white;
        padding: 15px;
        font-weight: 600;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .video-status {
        display: flex;
        gap: 5px;
    }
    
    .video-status-icon {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .video-muted::after {
        content: 'üîá';
        font-size: 12px;
    }
    
    .video-off::after {
        content: 'üìµ';
        font-size: 12px;
    }
    
    .video-wrapper.no-video::before {
        content: attr(data-username);
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 3em;
        color: white;
        background: rgba(0, 0, 0, 0.5);
        width: 100px;
        height: 100px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .controls {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
        padding: 20px;
        display: flex;
        justify-content: center;
        gap: 15px;
        flex-wrap: wrap;
        backdrop-filter: blur(10px);
        margin-bottom: 20px;
    }

    .control-btn {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        transition: all 0.3s ease;
        color: white;
    }

    .control-btn.video-on {
        background: #28a745;
    }

    .control-btn.video-off {
        background: #dc3545;
    }

    .control-btn.audio-on {
        background: #17a2b8;
    }

    .control-btn.audio-off {
        background: #dc3545;
    }

    .control-btn.screen-share {
        background: #6f42c1;
    }

    .control-btn.leave {
        background: #dc3545;
    }

    .control-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

    .room-info {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
        backdrop-filter: blur(10px);
        display: flex;
        flex-direction: column;
    }
    
    .room-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .participants-count {
        background: #007bff;
        color: white;
        border-radius: 20px;
        padding: 5px 12px;
        font-weight: bold;
    }

    .participants-list {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 10px;
    }

    .participant {
        background: #e9ecef;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 14px;
        display: flex;
        align-items: center;
    }
    
    .status-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 6px;
    }
    
    .status-online {
        background: #28a745;
    }

    .connection-status {
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 14px;
        margin-top: 10px;
        text-align: center;
    }

    .status-connected {
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
    }

    .status-connecting {
        background: #fff3cd;
        color: #856404;
        border: 1px solid #ffeaa7;
    }

    .status-disconnected {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
    }

    @media (max-width: 768px) {
        .video-container {
            grid-template-columns: 1fr !important;
        }
        
        .controls {
            gap: 10px;
        }
        
        .control-btn {
            width: 45px;
            height: 45px;
            font-size: 18px;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="room-info">
    <div class="room-header">
        <h2>üé• {{ room_name }}</h2>
        <div class="participants-count" id="participantsCount">
            1 Participant
        </div>
    </div>
    <p><strong>Room ID:</strong> {{ room_id }}</p>
    <p><strong>Your Name:</strong> {{ username }}</p>
    <p><strong>Your User ID:</strong> <span id="myUserId">{{ session.user_id }}</span></p>
    <div class="participants-list" id="participantsList">
        <div class="participant">
            <span class="status-indicator status-online"></span>
            {{ username }} (You)
        </div>
    </div>
    <div class="connection-status status-connecting" id="connectionStatus">
        üîÑ Connecting to room...
    </div>
</div>

<div class="video-container single" id="videoContainer">
    <div class="video-wrapper">
        <video id="localVideo" class="video-element" autoplay muted playsinline></video>
        <div class="video-overlay">
            <span>{{ username }} (You)</span>
            <div class="video-status" id="localVideoStatus">
                <!-- Status icons will be dynamically added -->
            </div>
        </div>
    </div>
</div>

<div class="controls">
    <button class="control-btn video-on" id="videoToggle" title="Toggle Video">
        üìπ
    </button>
    <button class="control-btn audio-on" id="audioToggle" title="Toggle Audio">
        üé§
    </button>
    <button class="control-btn screen-share" id="screenShare" title="Share Screen">
        üñ•Ô∏è
    </button>
    <button class="control-btn leave" id="leaveRoom" title="Leave Room">
        üìû
    </button>
</div>

<div class="text-center">
    <p style="color: rgba(255,255,255,0.8); font-size: 14px;">
        Share this URL with others to invite them: 
        <strong id="roomUrl">{{ request.url }}</strong>
        <button class="btn" onclick="copyRoomUrl()" style="margin-left: 10px; padding: 6px 12px; font-size: 12px;">
            üìã Copy
        </button>
    </p>
</div>
{% endblock %}

{% block extra_js %}
<script>
class VideoCallApp {
    constructor() {
        this.socket = null;
        this.localStream = null;
        this.peerConnections = new Map();
        this.isVideoEnabled = true;
        this.isAudioEnabled = true;
        this.isScreenSharing = false;
        this.roomId = '{{ room_id }}';
        this.username = '{{ username }}';
        this.userId = parseInt('{{ session.user_id }}');
        this.participantCount = 1; // Start with just yourself
        this.heartbeatInterval = null;
        this.connectionCheckInterval = null;
        
        console.log("My user ID:", this.userId);
        
        this.initializeElements();
        this.setupEventListeners();
        this.connectSocket();
        this.initializeMedia();
        this.startHeartbeat();
    }

    initializeElements() {
        this.localVideo = document.getElementById('localVideo');
        this.videoContainer = document.getElementById('videoContainer');
        this.videoToggle = document.getElementById('videoToggle');
        this.audioToggle = document.getElementById('audioToggle');
        this.screenShare = document.getElementById('screenShare');
        this.leaveRoom = document.getElementById('leaveRoom');
        this.participantsList = document.getElementById('participantsList');
        this.participantsCount = document.getElementById('participantsCount');
        this.connectionStatus = document.getElementById('connectionStatus');
    }

    setupEventListeners() {
        this.videoToggle.addEventListener('click', () => this.toggleVideo());
        this.audioToggle.addEventListener('click', () => this.toggleAudio());
        this.screenShare.addEventListener('click', () => this.toggleScreenShare());
        this.leaveRoom.addEventListener('click', () => this.leave());

        // Handle page unload
        window.addEventListener('beforeunload', () => {
            this.leave();
        });
    }
    
    connectSocket() {
        // Initialize Socket.IO with reconnection settings
        this.socket = io({
            reconnection: true,
            reconnectionAttempts: 10,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            timeout: 60000,
            transports: ['websocket', 'polling']
        });
        
        this.setupSocketEvents();
    }

    async initializeMedia() {
        try {
            this.localStream = await navigator.mediaDevices.getUserMedia({
                video: { 
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    facingMode: "user"
                },
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            });
            
            this.localVideo.srcObject = this.localStream;
            this.updateConnectionStatus('Connected to room', 'connected');
            
            // Join room after media is initialized
            this.joinRoom();
        } catch (error) {
            console.error('Error accessing media devices:', error);
            this.updateConnectionStatus('Media access denied: ' + error.message, 'disconnected');
            alert('Please allow camera and microphone access to use the video call.');
        }
    }

    setupSocketEvents() {
        this.socket.on('connect', () => {
            console.log('Connected to server with socket ID:', this.socket.id);
            this.updateConnectionStatus('Connected to server', 'connecting');
            
            // If we already have media, join the room
            if (this.localStream) {
                this.joinRoom();
            }
        });
        
        this.socket.on('connection_success', (data) => {
            console.log('Connection success:', data);
            this.updateConnectionStatus('Connected to server successfully', 'connected');
        });
        
        this.socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
            this.updateConnectionStatus('Connection error: ' + error.message, 'disconnected');
            
            // Try to reconnect with polling if websocket fails
            if (this.socket.io.opts.transports.indexOf('polling') === -1) {
                console.log('Trying to reconnect with polling transport');
                this.socket.io.opts.transports = ['polling', 'websocket'];
                this.socket.connect();
            }
        });

        this.socket.on('user_joined', async (data) => {
            console.log('User joined:', data.username, data.user_id);
            this.addParticipant(data.username, data.user_id);
            this.updateParticipantCount(1);
            
            // Initiate WebRTC connection to the new user
            await this.initiateCall(parseInt(data.user_id));
        });

        this.socket.on('user_left', (data) => {
            console.log('User left:', data.username, data.user_id);
            this.removeParticipant(data.user_id);
            this.updateParticipantCount(-1);
        });

        this.socket.on('room_users', async (users) => {
            console.log('Room users:', users);
            this.updateParticipantsList(users);
            this.updateParticipantCount(users.length - 1); // Excluding yourself
            
            // Create connections with all existing users
            for (const user of users) {
                if (parseInt(user.user_id) !== this.userId && !this.peerConnections.has(parseInt(user.user_id))) {
                    console.log("Initiating call to existing user:", user.user_id);
                    await this.initiateCall(parseInt(user.user_id));
                }
            }
        });

        // WebRTC signaling
        this.socket.on('webrtc_offer', async (data) => {
            console.log('Received offer from:', data.from_user, 'for:', data.target_user);
            
            // Only process if this offer is for me
            if (parseInt(data.target_user) === this.userId) {
                await this.handleOffer(data);
            }
        });

        this.socket.on('webrtc_answer', async (data) => {
            console.log('Received answer from:', data.from_user, 'for:', data.target_user);
            
            // Only process if this answer is for me
            if (parseInt(data.target_user) === this.userId) {
                await this.handleAnswer(data);
            }
        });

        this.socket.on('webrtc_ice_candidate', async (data) => {
            console.log('Received ICE candidate from:', data.from_user, 'for:', data.target_user);
            
            // Only process if this ICE candidate is for me
            if (parseInt(data.target_user) === this.userId) {
                await this.handleIceCandidate(data);
            }
        });
        
        this.socket.on('disconnect', () => {
            console.log('Disconnected from server');
            this.updateConnectionStatus('Disconnected from server', 'disconnected');
        });

        this.socket.on('media_status_change', (data) => {
            console.log('Media status change:', data);
            
            if (parseInt(data.user_id) === this.userId) return; // Ignore own status
            
            // Update remote video UI
            this.updateRemoteMediaStatus(parseInt(data.user_id), data.audio_enabled, data.video_enabled);
        });
    }

    joinRoom() {
        if (!this.socket || !this.socket.connected) {
            console.error('Socket not connected, cannot join room');
            setTimeout(() => this.joinRoom(), 2000); // Retry after 2 seconds
            return;
        }
        
        console.log("Joining room:", this.roomId, "as user:", this.userId);
        this.socket.emit('join_room', {
            room_id: this.roomId,
            username: this.username,
            user_id: this.userId
        });
    }
    
    async initiateCall(userId) {
        console.log('Initiating call to user:', userId);
        try {
            const peerConnection = await this.createPeerConnection(userId);
            
            const offer = await peerConnection.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
            });
            await peerConnection.setLocalDescription(offer);
            
            console.log("Sending offer to:", userId, "from:", this.userId);
            this.socket.emit('webrtc_offer', {
                room_id: this.roomId,
                offer: offer,
                target_user: userId,
                from_user: this.userId
            });
        } catch (error) {
            console.error('Error initiating call:', error);
            
            // Retry after a delay
            setTimeout(() => this.initiateCall(userId), 3000);
        }
    }

    async createPeerConnection(userId) {
        // Check if connection already exists
        if (this.peerConnections.has(userId)) {
            const existingConnection = this.peerConnections.get(userId);
            
            // If the connection is already closed, remove it and create a new one
            if (existingConnection.connectionState === 'closed' || 
                existingConnection.iceConnectionState === 'disconnected' || 
                existingConnection.iceConnectionState === 'failed') {
                this.peerConnections.delete(userId);
                console.log('Removing existing closed connection for user:', userId);
            } else {
                return existingConnection;
            }
        }
        
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
                {
                    urls: 'turn:numb.viagenie.ca',
                    credential: 'muazkh',
                    username: 'webrtc@live.com'
                },
                {
                    urls: 'turn:turn.anyfirewall.com:443?transport=tcp',
                    credential: 'webrtc',
                    username: 'webrtc'
                }
            ],
            iceCandidatePoolSize: 10
        };

        const peerConnection = new RTCPeerConnection(configuration);
        console.log('Created peer connection for user:', userId);

        // Add local stream
        if (this.localStream) {
            this.localStream.getTracks().forEach(track => {
                console.log('Adding track to peer connection:', track.kind);
                peerConnection.addTrack(track, this.localStream);
            });
        } else {
            console.error('No local stream available when creating peer connection');
            
            // Try to get media access if not available
            try {
                this.localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                
                this.localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, this.localStream);
                });
                
                this.localVideo.srcObject = this.localStream;
            } catch (err) {
                console.error('Could not get media access:', err);
            }
        }

        // Handle remote stream
        peerConnection.ontrack = (event) => {
            console.log('Received remote track from user:', userId, event.streams[0]);
            this.handleRemoteStream(event.streams[0], userId);
        };

        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('Sending ICE candidate to user:', userId);
                this.socket.emit('webrtc_ice_candidate', {
                    room_id: this.roomId,
                    candidate: event.candidate,
                    target_user: userId,
                    from_user: this.userId
                });
            }
        };
        
        // Connection state monitoring
        peerConnection.oniceconnectionstatechange = () => {
            console.log(`ICE connection state with ${userId}: ${peerConnection.iceConnectionState}`);
            
            if (peerConnection.iceConnectionState === 'connected' || 
                peerConnection.iceConnectionState === 'completed') {
                console.log(`Connection established with user ${userId}`);
                
                // Update the participant status
                const participantElement = document.getElementById(`participant-${userId}`);
                if (participantElement) {
                    const statusIndicator = participantElement.querySelector('.status-indicator');
                    if (statusIndicator) {
                        statusIndicator.className = 'status-indicator status-online';
                    }
                }
            }
            else if (peerConnection.iceConnectionState === 'failed' || 
                peerConnection.iceConnectionState === 'disconnected' ||
                peerConnection.iceConnectionState === 'closed') {
                
                console.log('Connection failed, attempting to reconnect...');
                
                // Update the participant status
                const participantElement = document.getElementById(`participant-${userId}`);
                if (participantElement) {
                    const statusIndicator = participantElement.querySelector('.status-indicator');
                    if (statusIndicator) {
                        statusIndicator.className = 'status-indicator';
                        statusIndicator.style.background = '#dc3545';
                    }
                }
                
                // Close and remove the existing connection
                peerConnection.close();
                this.peerConnections.delete(userId);
                
                // Try reconnecting after a delay
                setTimeout(() => {
                    this.initiateCall(userId);
                }, 3000);
            }
        };
        
        // Negotiation needed
        peerConnection.onnegotiationneeded = async () => {
            console.log('Negotiation needed with user:', userId);
            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                this.socket.emit('webrtc_offer', {
                    room_id: this.roomId,
                    offer: offer,
                    target_user: userId,
                    from_user: this.userId
                });
            } catch (error) {
                console.error('Error during negotiation:', error);
            }
        };

        this.peerConnections.set(userId, peerConnection);
        return peerConnection;
    }

    async handleOffer(data) {
        console.log('Handling offer from user:', data.from_user);
        try {
            const fromUserId = parseInt(data.from_user);
            const peerConnection = await this.createPeerConnection(fromUserId);
            
            // Check for collisions (both sides creating an offer)
            const isPolite = this.userId > fromUserId;
            
            try {
                if (peerConnection.signalingState !== 'stable') {
                    // If we're impolite, just ignore the offer
                    if (!isPolite) {
                        console.log('Ignoring offer (impolite) from:', fromUserId);
                        return;
                    }
                    
                    // If polite, rollback and continue
                    console.log('Signaling state collision, rolling back');
                    await Promise.all([
                        peerConnection.setLocalDescription({type: 'rollback'}),
                        peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer))
                    ]);
                } else {
                    // Stable state, proceed normally
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                }
                
                // Create and send answer
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                console.log("Sending answer to:", fromUserId, "from:", this.userId);
                this.socket.emit('webrtc_answer', {
                    room_id: this.roomId,
                    answer: answer,
                    target_user: fromUserId,
                    from_user: this.userId
                });
            } catch (err) {
                console.error('Error handling offer:', err);
                
                // If there was an error, close and recreate the connection
                peerConnection.close();
                this.peerConnections.delete(fromUserId);
                
                // Wait and try again with a new peer connection
                setTimeout(() => this.initiateCall(fromUserId), 2000);
            }
        } catch (error) {
            console.error('Error creating peer connection:', error);
        }
    }

    async handleAnswer(data) {
        console.log('Handling answer from user:', data.from_user);
        try {
            const fromUserId = parseInt(data.from_user);
            const peerConnection = this.peerConnections.get(fromUserId);
            if (peerConnection) {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                console.log('Successfully set remote description from answer');
            } else {
                console.error('No peer connection found for user:', fromUserId);
                
                // Create connection if it doesn't exist
                await this.initiateCall(fromUserId);
            }
        } catch (error) {
            console.error('Error handling answer:', error);
        }
    }

    async handleIceCandidate(data) {
        console.log('Handling ICE candidate from user:', data.from_user);
        try {
            const fromUserId = parseInt(data.from_user);
            const peerConnection = this.peerConnections.get(fromUserId);
            if (peerConnection) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                console.log('Successfully added ICE candidate');
            } else {
                console.error('No peer connection found for user:', fromUserId);
            }
        } catch (error) {
            console.error('Error handling ICE candidate:', error);
        }
    }

    handleRemoteStream(stream, userId) {
        console.log('Handling remote stream from user:', userId);
        
        // Check if video element already exists for this user
        const existingVideo = document.getElementById(`video-${userId}`);
        if (existingVideo) {
            const videoElement = existingVideo.querySelector('video');
            if (videoElement) {
                if (videoElement.srcObject !== stream) {
                    videoElement.srcObject = stream;
                    console.log('Updated existing video element with new stream');
                }
                return;
            }
        }
        
        // Get username for this user ID
        let username = 'User ' + userId;
        const participantElement = document.getElementById(`participant-${userId}`);
        if (participantElement) {
            username = participantElement.textContent.trim();
        }
        
        // Create video element for remote user
        const videoWrapper = document.createElement('div');
        videoWrapper.className = 'video-wrapper';
        videoWrapper.id = `video-${userId}`;

        const video = document.createElement('video');
        video.className = 'video-element';
        video.autoplay = true;
        video.playsinline = true;
        video.srcObject = stream;
        
        // Add event listeners to log when video starts playing
        video.onloadedmetadata = () => {
            console.log(`Remote video metadata loaded for user ${userId}`);
            video.play().catch(e => console.error('Error playing remote video:', e));
        };
        
        video.onplaying = () => {
            console.log(`Remote video is now playing for user ${userId}`);
            
            // Update the participant status
            const participantElement = document.getElementById(`participant-${userId}`);
            if (participantElement) {
                const statusIndicator = participantElement.querySelector('.status-indicator');
                if (statusIndicator) {
                    statusIndicator.className = 'status-indicator status-online';
                }
            }
        };

        const overlay = document.createElement('div');
        overlay.className = 'video-overlay';
        overlay.innerHTML = `
            <span>${username}</span>
            <div class="video-status" id="videoStatus-${userId}"></div>
        `;

        videoWrapper.appendChild(video);
        videoWrapper.appendChild(overlay);
        this.videoContainer.appendChild(videoWrapper);

        this.updateVideoLayout();
    }

    updateVideoLayout() {
        const videoCount = this.videoContainer.children.length;
        
        if (videoCount === 1) {
            this.videoContainer.className = 'video-container single';
        } else if (videoCount === 2) {
            this.videoContainer.className = 'video-container dual';
        } else if (videoCount === 3) {
            this.videoContainer.className = 'video-container triple';
        } else if (videoCount === 4) {
            this.videoContainer.className = 'video-container quad';
        } else {
            this.videoContainer.className = 'video-container multiple';
        }
        
        // Update all video aspects based on new layout
        const aspectRatio = videoCount <= 4 ? '16/9' : '4/3';
        const videoWrappers = this.videoContainer.querySelectorAll('.video-wrapper');
        videoWrappers.forEach(wrapper => {
            wrapper.style.aspectRatio = aspectRatio;
        });
    }

    toggleVideo() {
        if (this.localStream) {
            const videoTrack = this.localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                this.isVideoEnabled = videoTrack.enabled;
                
                this.videoToggle.className = this.isVideoEnabled ? 
                    'control-btn video-on' : 'control-btn video-off';
                this.videoToggle.textContent = this.isVideoEnabled ? 'üìπ' : 'üìπ';
                
                console.log('Video track enabled:', this.isVideoEnabled);
                
                // Update UI
                this.updateLocalMediaStatus();
                
                // Notify others about media status change
                this.broadcastMediaStatus();
            }
        }
    }

    toggleAudio() {
        if (this.localStream) {
            const audioTrack = this.localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                this.isAudioEnabled = audioTrack.enabled;
                
                this.audioToggle.className = this.isAudioEnabled ? 
                    'control-btn audio-on' : 'control-btn audio-off';
                this.audioToggle.textContent = this.isAudioEnabled ? 'üé§' : 'üîá';
                
                console.log('Audio track enabled:', this.isAudioEnabled);
                
                // Update UI
                this.updateLocalMediaStatus();
                
                // Notify others about media status change
                this.broadcastMediaStatus();
            }
        }
    }

    async toggleScreenShare() {
        try {
            if (!this.isScreenSharing) {
                // Start screen sharing
                const screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        cursor: "always"
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });

                // Replace video track in all peer connections
                const videoTrack = screenStream.getVideoTracks()[0];
                
                // Keep reference to camera stream before replacing
                this.cameraStream = this.localStream;
                
                // Store screen sharing stream
                this.screenSharingStream = screenStream;
                
                // Replace tracks in all peer connections
                this.peerConnections.forEach(async (peerConnection) => {
                    const senders = peerConnection.getSenders();
                    const videoSender = senders.find(s => 
                        s.track && s.track.kind === 'video'
                    );
                    
                    if (videoSender) {
                        await videoSender.replaceTrack(videoTrack);
                        console.log('Replaced video track with screen share');
                    }
                });

                // Update local video
                this.localVideo.srcObject = screenStream;
                this.isScreenSharing = true;
                this.screenShare.style.background = '#28a745';

                // Handle screen share end
                videoTrack.onended = () => {
                    this.stopScreenShare();
                };

            } else {
                this.stopScreenShare();
            }
        } catch (error) {
            console.error('Error sharing screen:', error);
        }
    }

    async stopScreenShare() {
        if (!this.isScreenSharing) return;
        
        if (this.cameraStream) {
            const videoTrack = this.cameraStream.getVideoTracks()[0];
            
            // Replace screen share with camera in all peer connections
            this.peerConnections.forEach(async (peerConnection) => {
                const sender = peerConnection.getSenders().find(s => 
                    s.track && s.track.kind === 'video'
                );
                if (sender && videoTrack) {
                    await sender.replaceTrack(videoTrack);
                    console.log('Replaced screen share with camera');
                }
            });

            // Restore local video
            this.localVideo.srcObject = this.cameraStream;
            
            // Stop all tracks in screen sharing stream
            if (this.screenSharingStream) {
                this.screenSharingStream.getTracks().forEach(track => {
                    track.stop();
                });
            }
        }

        this.isScreenSharing = false;
        this.screenShare.style.background = '#6f42c1';
    }

    addParticipant(username, userId) {
        // Check if participant already exists
        if (document.getElementById(`participant-${userId}`)) {
            return;
        }
        
        const participant = document.createElement('div');
        participant.className = 'participant';
        participant.id = `participant-${userId}`;
        participant.innerHTML = `
            <span class="status-indicator" style="background: #ffc107;"></span>
            ${username}
        `;
        this.participantsList.appendChild(participant);
        
        console.log(`Participant added: ${username} (${userId})`);
    }

    removeParticipant(userId) {
        const participant = document.getElementById(`participant-${userId}`);
        if (participant) {
            participant.remove();
            console.log(`Participant removed: ${userId}`);
        }

        // Remove video element
        const videoElement = document.getElementById(`video-${userId}`);
        if (videoElement) {
            videoElement.remove();
            this.updateVideoLayout();
            console.log(`Video element removed for user: ${userId}`);
        }

        // Close peer connection
        const peerConnection = this.peerConnections.get(parseInt(userId));
        if (peerConnection) {
            peerConnection.close();
            this.peerConnections.delete(parseInt(userId));
            console.log(`Peer connection closed for user: ${userId}`);
        }
    }

    updateParticipantsList(users) {
        // Clear existing participants (except self)
        const participants = this.participantsList.querySelectorAll('.participant:not(:first-child)');
        participants.forEach(p => p.remove());

        // Add current users
        users.forEach(user => {
            if (parseInt(user.user_id) !== this.userId) {
                this.addParticipant(user.username, user.user_id);
            }
        });
        
        console.log(`Participants list updated with ${users.length} users`);
    }
    
    updateParticipantCount(change) {
        // Update participant count (adding or subtracting)
        if (change !== 0) {
            this.participantCount += change;
            if (this.participantCount < 1) this.participantCount = 1; // Ensure at least 1 (yourself)
            
            const participantText = this.participantCount === 1 ? 'Participant' : 'Participants';
            this.participantsCount.textContent = `${this.participantCount} ${participantText}`;
        }
    }

    updateConnectionStatus(message, status) {
        this.connectionStatus.textContent = message;
        this.connectionStatus.className = `connection-status status-${status}`;
        console.log(`Connection status: ${message} (${status})`);
    }

    startHeartbeat() {
        // Poll for active participants every 10 seconds
        this.heartbeatInterval = setInterval(() => {
            this.checkRoomStatus();
        }, 10000);
        
        // Check connection status of peers every 5 seconds
        this.connectionCheckInterval = setInterval(() => {
            this.checkPeerConnections();
        }, 5000);
    }
    
    stopHeartbeat() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
        
        if (this.connectionCheckInterval) {
            clearInterval(this.connectionCheckInterval);
            this.connectionCheckInterval = null;
        }
    }
    
    async checkRoomStatus() {
        try {
            const response = await fetch(`/api/rooms/${this.roomId}/status`);
            const data = await response.json();
            
            if (data.error) {
                console.error('Room status error:', data.error);
                return;
            }
            
            // Update participant count
            const participantCount = data.active_participants_count;
            if (participantCount !== this.participantCount) {
                this.participantCount = participantCount;
                const participantText = this.participantCount === 1 ? 'Participant' : 'Participants';
                this.participantsCount.textContent = `${this.participantCount} ${participantText}`;
            }
            
            // Check for any new participants that we might have missed
            const knownParticipantIds = Array.from(this.peerConnections.keys());
            const serverParticipantIds = data.participants.map(p => parseInt(p.user_id)).filter(id => id !== this.userId);
            
            // Look for participants on the server that we don't have connections with
            for (const participantId of serverParticipantIds) {
                if (!knownParticipantIds.includes(participantId)) {
                    console.log(`Discovered missing participant: ${participantId}`);
                    
                    // Find username
                    const participant = data.participants.find(p => parseInt(p.user_id) === participantId);
                    if (participant) {
                        // Add participant to UI
                        this.addParticipant(participant.username, participantId);
                        
                        // Initiate call
                        await this.initiateCall(participantId);
                    }
                }
            }
            
            // Look for participants we have connections with but are not on the server
            for (const participantId of knownParticipantIds) {
                if (!serverParticipantIds.includes(participantId)) {
                    console.log(`Removing stale participant: ${participantId}`);
                    this.removeParticipant(participantId);
                }
            }
            
        } catch (error) {
            console.error('Error checking room status:', error);
        }
    }
    
    checkPeerConnections() {
        for (const [userId, peerConnection] of this.peerConnections.entries()) {
            const state = peerConnection.iceConnectionState;
            console.log(`Checking peer ${userId} connection state: ${state}`);
            
            // Update UI based on connection state
            const participantElement = document.getElementById(`participant-${userId}`);
            if (participantElement) {
                const statusIndicator = participantElement.querySelector('.status-indicator');
                if (statusIndicator) {
                    if (state === 'connected' || state === 'completed') {
                        statusIndicator.className = 'status-indicator status-online';
                    } else if (state === 'checking' || state === 'new') {
                        statusIndicator.style.background = '#ffc107'; // yellow/amber
                    } else {
                        statusIndicator.style.background = '#dc3545'; // red
                    }
                }
            }
            
            // If disconnected for a while, attempt to reconnect
            if (state === 'disconnected' || state === 'failed' || state === 'closed') {
                console.log(`Connection with peer ${userId} is ${state}, attempting to reconnect`);
                
                // Close existing connection
                peerConnection.close();
                this.peerConnections.delete(userId);
                
                // Attempt to reconnect
                setTimeout(() => {
                    this.initiateCall(userId);
                }, 1000);
            }
        }
    }

    leave() {
        // Stop heartbeat
        this.stopHeartbeat();
        
        // Clean up streams
        if (this.localStream) {
            this.localStream.getTracks().forEach(track => {
                track.stop();
                console.log(`Stopped ${track.kind} track`);
            });
        }
        
        // Stop screen sharing if active
        if (this.isScreenSharing && this.screenSharingStream) {
            this.screenSharingStream.getTracks().forEach(track => {
                track.stop();
            });
        }

        // Close all peer connections
        this.peerConnections.forEach((peerConnection, userId) => {
            peerConnection.close();
            console.log(`Closed peer connection with user: ${userId}`);
        });
        this.peerConnections.clear();

        // Leave room
        if (this.socket && this.socket.connected) {
            this.socket.emit('leave_room', {
                room_id: this.roomId
            });
            console.log(`Left room: ${this.roomId}`);
        }

        // Redirect to home
        window.location.href = '/';
    }

    updateLocalMediaStatus() {
        const statusContainer = document.getElementById('localVideoStatus');
        if (statusContainer) {
            // Clear previous status
            statusContainer.innerHTML = '';
            
            // Add audio status if needed
            if (!this.isAudioEnabled) {
                const audioStatus = document.createElement('div');
                audioStatus.className = 'video-status-icon video-muted';
                statusContainer.appendChild(audioStatus);
            }
            
            // Add video status if needed
            if (!this.isVideoEnabled) {
                const videoStatus = document.createElement('div');
                videoStatus.className = 'video-status-icon video-off';
                statusContainer.appendChild(videoStatus);
                
                // Apply visual indicator for disabled video
                const localVideoWrapper = document.querySelector('.video-wrapper');
                if (localVideoWrapper) {
                    localVideoWrapper.classList.add('no-video');
                    localVideoWrapper.setAttribute('data-username', this.username.substring(0, 1).toUpperCase());
                }
            } else {
                // Remove visual indicator if video is enabled
                const localVideoWrapper = document.querySelector('.video-wrapper');
                if (localVideoWrapper) {
                    localVideoWrapper.classList.remove('no-video');
                }
            }
        }
    }
    
    broadcastMediaStatus() {
        if (!this.socket || !this.socket.connected) return;
        
        this.socket.emit('media_status_change', {
            room_id: this.roomId,
            user_id: this.userId,
            audio_enabled: this.isAudioEnabled,
            video_enabled: this.isVideoEnabled
        });
    }

    updateRemoteMediaStatus(userId, audioEnabled, videoEnabled) {
        const videoWrapper = document.getElementById(`video-${userId}`);
        if (!videoWrapper) return;
        
        const statusContainer = videoWrapper.querySelector('.video-status');
        if (statusContainer) {
            // Clear previous status
            statusContainer.innerHTML = '';
            
            // Add audio status if needed
            if (!audioEnabled) {
                const audioStatus = document.createElement('div');
                audioStatus.className = 'video-status-icon video-muted';
                statusContainer.appendChild(audioStatus);
            }
            
            // Add video status if needed
            if (!videoEnabled) {
                const videoStatus = document.createElement('div');
                videoStatus.className = 'video-status-icon video-off';
                statusContainer.appendChild(videoStatus);
                
                // Visual indicator for disabled video
                videoWrapper.classList.add('no-video');
                
                // Get first letter of username
                const overlay = videoWrapper.querySelector('.video-overlay');
                let username = 'U';
                if (overlay) {
                    username = overlay.textContent.trim().substring(0, 1).toUpperCase();
                }
                videoWrapper.setAttribute('data-username', username);
            } else {
                // Remove visual indicator if video is enabled
                videoWrapper.classList.remove('no-video');
            }
        }
    }
}

// Utility functions
function copyRoomUrl() {
    const roomUrl = document.getElementById('roomUrl').textContent;
    navigator.clipboard.writeText(roomUrl).then(() => {
        alert('Room URL copied to clipboard!');
    }).catch(err => {
        console.error('Failed to copy URL:', err);
    });
}

// Initialize the app when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    new VideoCallApp();
});
</script>
{% endblock %} 